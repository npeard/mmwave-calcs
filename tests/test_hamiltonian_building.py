import sys
import os
import pytest
import numpy as np

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.dirname(SCRIPT_DIR))

from models.spin_chain import LatticeGraph, DiagonEngine
from models.floquet_program import XYAntiSymmetricProgram

# Define helper functions used in both methods
def DM_z_period4(t, i):
    phase = np.pi / 2 * (i % 4)
    if t == "+DM":
        return phase
    elif t == "-DM":
        return -phase
    else:
        return 0

def XY_z_period4(t, i):
    phase = np.pi - 3. * np.pi / 2 * (i % 4)
    if t == "+XY":
        return phase
    elif t == "-XY":
        return -phase
    else:
        return 0

def native(t, i, j):
    if t in ["+DM", "-DM", "+XY", "-XY"]:
        # This is only valid because we are considering phase rotations
        # that occur in zero time here.
        return 0
    else:
        return 0.5

@pytest.mark.parametrize("num_sites", [2, 3, 4])
@pytest.mark.parametrize("time_param", ["nat", "+DM", "-XY"])
def test_hamiltonian_equivalence(num_sites, time_param):
    """Test that Hamiltonians generated by different methods are equivalent."""
    # Method 1: Using LatticeGraph and DiagonEngine
    terms = [
        ['XX', native, 'nn'],
        ['yy', native, 'nn'],
        ['z', DM_z_period4, np.inf],
        ['z', XY_z_period4, np.inf]
    ]
    graph = LatticeGraph.from_interactions(num_sites, terms, pbc=False)
    computation = DiagonEngine(graph)
    H1 = computation.get_quspin_hamiltonian(time_param)

    # Method 2: Using FloquetOptimizer
    program = XYAntiSymmetricProgram(num_sites)
    H2 = program._build_native_hamiltonian(time_param)

    # Convert both to dense numpy arrays for comparison
    H1_dense = H1.todense() if hasattr(H1, 'todense') else H1
    H2_dense = H2.detach().numpy() if hasattr(H2, 'detach') else H2

    # Compare matrices
    np.testing.assert_allclose(
        H1_dense,
        H2_dense,
        rtol=1e-7,
        err_msg=f"Hamiltonians don't match for num_sites={num_sites}, time={time_param}"
    )

@pytest.mark.parametrize("time_param", ["nat", "+DM", "-DM", "+XY", "-XY"])
@pytest.mark.parametrize("site_idx", [0, 1, 2, 3])
def test_helper_function_equivalence(time_param, site_idx):
    """Test that helper functions match XYAntiSymmetricProgram methods."""
    import torch
    program = XYAntiSymmetricProgram(num_sites=4)

    # Test DM_z_period4
    helper_dm = DM_z_period4(time_param, site_idx)
    program_dm = program.DM_z_period4_torch(
        time_param,
        site_idx,
        phase_factor=torch.tensor(np.pi/2, dtype=torch.float64)
    )
    np.testing.assert_allclose(
        helper_dm,
        program_dm.item() if hasattr(program_dm, 'item') else program_dm,
        rtol=1e-7,
        err_msg=f"DM_z_period4 functions don't match for time={time_param}, site={site_idx}"
    )

    # Test XY_z_period4
    helper_xy = XY_z_period4(time_param, site_idx)
    program_xy = program.XY_z_period4_torch(
        time_param,
        site_idx,
        base_phase=torch.tensor(np.pi, dtype=torch.float64),
        phase_factor=torch.tensor(3*np.pi/2, dtype=torch.float64)
    )
    np.testing.assert_allclose(
        helper_xy,
        program_xy.item() if hasattr(program_xy, 'item') else program_xy,
        rtol=1e-7,
        err_msg=f"XY_z_period4 functions don't match for time={time_param}, site={site_idx}"
    )

    # Test native interaction
    for neighbor_idx in range(4):
        if neighbor_idx != site_idx:
            helper_nat = native(time_param, site_idx, neighbor_idx)
            program_nat = program.native_off_torch(
                time_param,
                site_idx,
                neighbor_idx,
                coupling=torch.tensor(0.5, dtype=torch.float64)
            )
            np.testing.assert_allclose(
                helper_nat,
                program_nat.item() if hasattr(program_nat, 'item') else program_nat,
                rtol=1e-7,
                err_msg=f"native functions don't match for time={time_param}, sites=({site_idx}, {neighbor_idx})"
            )
